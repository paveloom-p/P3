module poly
implicit none
contains

!-----------

function poly1(n ,x ,m) result(y)
integer n, i
real y,x
real,dimension(100)::m

y=m(1)
do i=1, n, 1                !
y=y*x+m(i+1)                ! 
enddo

end function poly1

!-----------

function poly2(x, m, n)

integer i, n
real poly2(2), m(0:n), s1, s2, ax, x2,x
ax=abs(x)
select case (n)
  case(0); poly2(1)=m(0); poly2(2)=m(0); return
  case(1); poly2(1)=m(1)+ax*m(0); poly2(2)=m(1)-ax*m(0); return
  case default; x2=x*x; s1=m(0); do i=2,n,2; s1=s1*x2+m(i); enddo
                        s2=m(1); do i=3,n,2; s2=s2*x2+m(i); enddo
  if (mod(n,2)==0) then; poly2(1)=s1+ax*s2; poly2(2)=s1-ax*s2
                   else; poly2(1)=s2+ax*s1; poly2(2)=s2-ax*s1
  endif
endselect

end function poly2

!-----------
!   Так нельзя!!! Вы же ничего не присваиваете функции poly3,
!   хотя и сообщаете, что тип возвращаемого результата integer
!   Вот Ваша программа и печатает дикие целые, причём раз от раза
!   различные при вызовах вроде write(*,*) poly3(n,t)
!
!   Пожалуйста, исправьте, учтя остальные замечания


!   П: Увидел, исправил.

function poly3(n, t) result (c)   ! Лучше так. Тогда не нужно
integer i, n, t(:)                ! описывать integer poly3
                                  ! ==============================
!integer poly3                      Если же без с, то тогда
!                                  integer poly3(-16:16) и всюду
!                                  вместо  c poly3
integer c(-16:16)                 ! а ту строчку закомментировать 
! ====================================================================
do i=-16, 16, 1   !     ГОРАЗДО ПРОЩЕ:       с=0
c(i)=0            !
enddo             ! а так как у ВАС --- так нужно было в старом ФОРТРАНе
!=====================================================================

do i=1,n
c(t(i))=c(t(i))+1
enddo

!======================= Дело процедуры --- вычислить результат, а как
!                        им воспользоваться решает вызвавшая процедуру 
!                        программа: захочет выведет на печать, захочет
! будет использовать в дальнейших расчётах без вывода второстепенного.
!..................................................................... 
!write(*,'(i3,i15)') (i,c(i),i=-16,16)
end function poly3

!-----------

function poly4(v) result(a)
integer v, k, c, i           
integer a(32)

k=abs(v)

if (v .ge. 0) then
do i=1, 32, 1
  c=mod(k,2)
  a(i)=c
  k=k/2  ! Почему не просто k=k/2 ?
             ! П: Потому что необходимо деление без остатка.
! ======================================================================
! РАЗ деление целочисленное, ОБА ОПЕРАНДА --- ЦЕЛЫЕ !!!
! то оно по определению без остатка.
! И в СИ, и в ФОРТРАНе тип операции деления определяется
! по типу операндов. Если хотя бы один операнд вещественный
! то деление вещественное, если целый, то деление нацело
! Это --- первый семестр!!!
! ======================================================================
  
enddo         

!........................................................................
! 1) Слишком сложная форма реализации, того, что можно было записать

!                                   a=1-a

! 2) Это Вы преобрвазовали прямой код в обратный.
!    А чтобы получить дополнительный надо к обратному добавить 1:


else
k=k-1

do i=1, 32, 1
  c=mod(k,2)
  a(i)=c
  k=k/2 
enddo

a=1-a
!write(*,'(32i1)') (a(i),i=32,1,-1)

!do i=1, 32, 1
!if (a(i) .eq. 0) then
!        a(i)=a(i)+1
!        if (i .gt. 1) then
!                a(i-1)=0
!        endif
!      exit
!endif
!enddo

endif


end function poly4

!-----------

end module poly
