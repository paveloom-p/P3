module binrad
implicit none
contains
!-----------
function binrad5(a) result(k)
integer a(:), i
integer k
!integer binrad5     

!k=a(1); do i=2, size(a);  k=k*2+a(i); enddo

if (a(1) .eq. 0) then
    k=a(1); do i=2, size(a); k=k*2+a(i); enddo
  else  !if (a(1) .eq. 1) then  ! А разве может быть ИНАЧЕ:
                                ! Если a(1) не равно 0, то равно
                                ! только 1. Так что зачем
                                ! лишний раз проверять?

                                ! П: Не может, конечно. Но это как
                                !    писать .eq. вместо ==
                                !    -- входит в привычку. 

!.....................................................................
!!!     do i=size(a), 1, -1                              !  Почему
!!!       if (a(i) .eq. 1 .and. i .ne. size(a)) then     !
!!!         a(i)=0                                       !    так
!!!         do j=i+1, size(a); a(j)=1; enddo             !
!!!         exit                                         !  сложно?
!!!       elseif (a(i) .eq. 1 .and. i .eq. size(a)) then !
!!!           a(i)=0                   ! Ведь аргумент всегда 32-битовый.
!!!           exit                     ! т.е. На вход  должны подаватся
!!!       endif                        ! 32 бита. А тогда     a=1-a
!!!     enddo                          ! даст в чистом виде положительное 
!!!                                    ! число, которое на 1 больше
!!!     !write(*,*) a                  ! нужного модуля отрицательного
!!!                                    ! Так что после 
!!!!     do i=1, size(a)
!!!!       if (a(i) .eq. 1) then; a(i)=0 !
!!!!                      else; a(i)=1   !
!!!!       endif                         !
!!!!     enddo                           !

!write(*,*) a
     a=1-a
!write(*,*) a
     k=a(1)                              ! Этого Вашего подсчёта
     do i=2, size(a); k=k*2+a(i); enddo  ! 

!write(*,*) k                                         ! останется написать
     k=-1-k                              !     k=-1-k
!write(*,*) k

!==========================================================
! Учтя замечания и Ваш слегка модернизированный (как?) фрагмент
!  (без a=1-a)!!!
!   ========= 
!      k=a(1) ???; do i=2, size(a);  k=k*2+a(i); enddo

! Вы можете очень просто из найденного k вычислить  соответствующий
! k  аналог отрицательного числа, модель которого записана в a.

!                               СООБРАЗИТЕ,  КАК!

! П: Так вот же оно, вы же сами написали, что фокус в k=-1-k.
!    Увидели единицу в старшем разряде, перевели в обратный,
!    посчитали значение k, а потом сделали его отрицательным
!    и вычли единичку, так как нам при преобразовании в
!    прямой код её следовало бы прибавить.

!    Этот алгоритм завершен, что же мне ещё здесь сделать?

!    Число 128 действительно не влезет в integer(1).
!    Однако диапазон результатов выглядит как [-128,127], и
!    за него, как ни старайся, мы выбраться не сможем.
!===========================================================
endif

end function binrad5

!-----------

function binrad6(a) result(b)       !  Будем считать, что числа всегда положительны.
integer a(:), i, k, c, b(size(a))   !  Хорошо! Здесь согласен,
!integer binrad6                    !  что число можно считать
                                    !  положительным, поскольку
k=a(1)                              !  алгоритм перевода не
do i=2, size(a), 1                  !  затрагивает величины, а только 
        k=k*2+a(i)                  !  форму записи.
enddo
				    !  П: Исправил вывод.
do i=1, size(b), 1
        c=mod(k,8)
        k=(k-c)/8
        b(size(b)+1-i)=c
enddo

end function binrad6

!-----------

end module binrad
